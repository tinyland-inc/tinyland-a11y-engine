import type { AccessibilityTestResult, ContrastTestResult } from './types';
import type { Result } from 'axe-core';
import { JsonReportGenerator } from './JsonReportGenerator';

export class MarkdownReportGenerator {
  private jsonGenerator: JsonReportGenerator;

  constructor() {
    this.jsonGenerator = new JsonReportGenerator();
  }

  generateReport(results: AccessibilityTestResult[]): string {
    const report = this.jsonGenerator.generateReport(results);
    const timestamp = new Date();
    
    let markdown = `# Accessibility Report

Generated: ${timestamp.toLocaleString()}

## Executive Summary

${this.generateExecutiveSummary(report)}

## Test Results Overview

${this.generateResultsTable(report)}

## Severity Breakdown

${this.generateSeverityBreakdown(report)}

## Results by Theme

${this.generateThemeResults(report)}

## Results by Route

${this.generateRouteResults(report)}

## Top Issues

${this.generateTopIssues(report)}

## Actionable Items

${this.generateActionableItems(report)}

## Contrast Failures

${this.generateContrastFailures(report)}

## Component Analysis

${this.generateComponentAnalysis(report)}

## Recommendations

${this.generateRecommendations(report)}

---

*This report was automatically generated by the Tinyland.dev accessibility testing suite.*
*For more information about WCAG 2.1 compliance, visit [WCAG Quick Reference](https://www.w3.org/WAI/WCAG21/quickref/)*
`;

    return markdown;
  }

  private generateExecutiveSummary(report: any): string {
    const { summary } = report;
    const status = summary.violations.critical > 0 ? 'ðŸš¨ **CRITICAL**' : 
                  summary.failed > 0 ? 'âš ï¸ **NEEDS ATTENTION**' : 
                  'âœ… **PASSING**';
    
    return `
### Status: ${status}

- **Success Rate**: ${summary.successRate.toFixed(1)}%
- **Total Tests**: ${summary.totalTests}
- **Passed**: ${summary.passed}
- **Failed**: ${summary.failed}
- **Total Violations**: ${summary.violations.total}

${summary.violations.critical > 0 ? 
  `> **âš ï¸ Critical Issues Found**: There are ${summary.violations.critical} critical accessibility violations that must be addressed immediately.` : 
  summary.failed > 0 ?
  `> **Note**: While no critical issues were found, there are ${summary.violations.total} accessibility violations that should be addressed.` :
  `> **Excellent!** All accessibility tests are passing.`}
`;
  }

  private generateResultsTable(report: any): string {
    const { summary } = report;
    
    return `
| Metric | Value |
|--------|-------|
| Total Tests | ${summary.totalTests} |
| Passed | ${summary.passed} |
| Failed | ${summary.failed} |
| Success Rate | ${summary.successRate.toFixed(1)}% |
| Test Duration | ${(summary.duration / 1000).toFixed(2)}s |
`;
  }

  private generateSeverityBreakdown(report: any): string {
    const { violations } = report.summary;
    
    return `
| Severity | Count | Percentage |
|----------|-------|------------|
| Critical | ${violations.critical} | ${this.getPercentage(violations.critical, violations.total)}% |
| Serious | ${violations.serious} | ${this.getPercentage(violations.serious, violations.total)}% |
| Moderate | ${violations.moderate} | ${this.getPercentage(violations.moderate, violations.total)}% |
| Minor | ${violations.minor} | ${this.getPercentage(violations.minor, violations.total)}% |
| **Total** | **${violations.total}** | **100%** |
`;
  }

  private generateThemeResults(report: any): string {
    const { byTheme } = report.results;
    let markdown = `
| Theme | Passed | Failed | Violations | Critical Issues |
|-------|--------|--------|------------|-----------------|
`;
    
    Object.entries(byTheme).forEach(([theme, data]: [string, any]) => {
      markdown += `| ${theme} | ${data.passed} | ${data.failed} | ${data.violations} | ${data.criticalIssues} |\n`;
    });
    
    return markdown;
  }

  private generateRouteResults(report: any): string {
    const { byRoute } = report.results;
    let markdown = `
| Route | Passed | Failed | Violations | Theme Status |
|-------|--------|--------|------------|--------------|
`;
    
    Object.entries(byRoute)
      .sort(([, a]: any, [, b]: any) => b.violations - a.violations)
      .slice(0, 10)
      .forEach(([route, data]: [string, any]) => {
        const themeStatus = Object.entries(data.themes)
          .map(([theme, passed]) => `${theme}: ${passed ? 'âœ…' : 'âŒ'}`)
          .join(', ');
        markdown += `| ${route} | ${data.passed} | ${data.failed} | ${data.violations} | ${themeStatus} |\n`;
      });
    
    return markdown;
  }

  private generateTopIssues(report: any): string {
    const { violations } = report;
    let markdown = `
### Most Common Violations

`;
    
    violations.slice(0, 10).forEach((violation: any, index: number) => {
      markdown += `
#### ${index + 1}. ${violation.id}

- **Impact**: ${violation.impact}
- **Description**: ${violation.description}
- **Occurrences**: ${violation.occurrences}
- **WCAG Criteria**: ${violation.wcagCriteria.join(', ')}
- **Help**: ${violation.help}
- **Learn More**: [${violation.helpUrl}](${violation.helpUrl})

`;
    });
    
    return markdown;
  }

  private generateActionableItems(report: any): string {
    const { actionableItems } = report;
    let markdown = `
### Priority Actions

`;
    
    const byPriority = {
      immediate: actionableItems.filter((i: any) => i.priority === 'immediate'),
      high: actionableItems.filter((i: any) => i.priority === 'high'),
      medium: actionableItems.filter((i: any) => i.priority === 'medium'),
      low: actionableItems.filter((i: any) => i.priority === 'low')
    };
    
    if (byPriority.immediate.length > 0) {
      markdown += `
#### ðŸš¨ Immediate Actions Required

| Issue | Solution | Components | Effort |
|-------|----------|------------|--------|
`;
      byPriority.immediate.forEach((item: any) => {
        markdown += `| ${item.issue} | ${item.solution} | ${item.affectedComponents.join(', ')} | ${item.estimatedEffort} |\n`;
      });
    }
    
    if (byPriority.high.length > 0) {
      markdown += `
#### âš ï¸ High Priority

| Issue | Solution | Components | Effort |
|-------|----------|------------|--------|
`;
      byPriority.high.slice(0, 5).forEach((item: any) => {
        markdown += `| ${item.issue} | ${item.solution} | ${item.affectedComponents.join(', ')} | ${item.estimatedEffort} |\n`;
      });
    }
    
    return markdown;
  }

  private generateContrastFailures(report: any): string {
    const { contrastFailures } = report;
    if (contrastFailures.length === 0) {
      return `
No contrast failures detected. All text meets WCAG contrast requirements.
`;
    }
    
    let markdown = `
### Worst Contrast Ratios

| Selector | Ratio | Required | Colors | Routes | Themes |
|----------|-------|----------|--------|--------|--------|
`;
    
    contrastFailures.slice(0, 10).forEach((failure: any) => {
      markdown += `| ${failure.selector} | ${failure.ratio.toFixed(2)}:1 | ${failure.requiredRatio}:1 | FG: ${failure.foreground}<br>BG: ${failure.background} | ${failure.routes.length} | ${failure.themes.join(', ')} |\n`;
    });
    
    return markdown;
  }

  private generateComponentAnalysis(report: any): string {
    const { byComponent } = report.results;
    let markdown = `
### Components with Most Issues

| Component | Occurrences | Severity | Violation Types |
|-----------|-------------|----------|-----------------|
`;
    
    Object.entries(byComponent)
      .sort(([, a]: any, [, b]: any) => b.occurrences - a.occurrences)
      .slice(0, 15)
      .forEach(([component, data]: [string, any]) => {
        markdown += `| ${component} | ${data.occurrences} | ${data.severity} | ${data.violations.join(', ')} |\n`;
      });
    
    return markdown;
  }

  private generateRecommendations(report: any): string {
    const { summary, violations, contrastFailures } = report;
    let recommendations: string[] = [];
    
    if (summary.violations.critical > 0) {
      recommendations.push('1. **Immediately address all critical violations** - These prevent users from accessing content');
    }
    
    if (contrastFailures.length > 0) {
      recommendations.push(`2. **Fix contrast issues** - ${contrastFailures.length} elements fail WCAG contrast requirements`);
    }
    
    const ariaViolations = violations.filter((v: any) => v.id.includes('aria'));
    if (ariaViolations.length > 0) {
      recommendations.push('3. **Review ARIA implementation** - Incorrect ARIA attributes can make content less accessible');
    }
    
    const keyboardViolations = violations.filter((v: any) => 
      v.id.includes('keyboard') || v.id.includes('focus')
    );
    if (keyboardViolations.length > 0) {
      recommendations.push('4. **Ensure keyboard accessibility** - All interactive elements must be keyboard accessible');
    }
    
    if (Object.keys(report.results.byComponent).length > 20) {
      recommendations.push('5. **Create reusable accessible components** - Standardize components to reduce violations');
    }
    
    recommendations.push('6. **Implement automated testing** - Add accessibility tests to your CI/CD pipeline');
    recommendations.push('7. **Conduct manual testing** - Automated tests catch ~30% of issues; manual testing is essential');
    recommendations.push('8. **Train your team** - Ensure developers understand accessibility requirements');
    
    return `
### Key Recommendations

${recommendations.join('\n')}

### Next Steps

1. Fix all critical and serious violations
2. Address contrast failures systematically
3. Review and fix ARIA implementations
4. Test with real assistive technologies
5. Set up continuous accessibility monitoring

### Resources

- [WCAG 2.1 Guidelines](https://www.w3.org/WAI/WCAG21/quickref/)
- [WebAIM Contrast Checker](https://webaim.org/resources/contrastchecker/)
- [ARIA Authoring Practices](https://www.w3.org/TR/wai-aria-practices-1.1/)
- [Inclusive Design Principles](https://inclusivedesignprinciples.org/)
`;
  }

  private getPercentage(value: number, total: number): string {
    if (total === 0) return '0';
    return ((value / total) * 100).toFixed(1);
  }

  generatePRComment(results: AccessibilityTestResult[]): string {
    const report = this.jsonGenerator.generateReport(results);
    const { summary } = report;
    
    const status = summary.violations.critical > 0 ? 'ðŸš¨' : 
                  summary.failed > 0 ? 'âš ï¸' : 'âœ…';
    
    let comment = `## ${status} Accessibility Test Results

**Success Rate**: ${summary.successRate.toFixed(1)}% (${summary.passed}/${summary.totalTests} tests passed)

`;

    if (summary.violations.total > 0) {
      comment += `### Violations Summary

| Severity | Count |
|----------|-------|
| Critical | ${summary.violations.critical} |
| Serious | ${summary.violations.serious} |
| Moderate | ${summary.violations.moderate} |
| Minor | ${summary.violations.minor} |

`;

      if (summary.violations.critical > 0) {
        comment += `> **ðŸš¨ Critical Issues**: This PR introduces ${summary.violations.critical} critical accessibility violations that must be fixed before merging.\n\n`;
      }

      // Add top 3 issues
      const topIssues = report.violations.slice(0, 3);
      if (topIssues.length > 0) {
        comment += `### Top Issues to Address

`;
        topIssues.forEach((issue: any, index: number) => {
          comment += `${index + 1}. **${issue.id}** (${issue.impact}): ${issue.help} - [Learn more](${issue.helpUrl})\n`;
        });
      }
    } else {
      comment += `âœ… **All accessibility tests passed!** Great job maintaining accessibility standards.\n`;
    }

    comment += `
<details>
<summary>View Full Report</summary>

[View HTML Report](../artifacts/accessibility-report.html) | [Download JSON Report](../artifacts/accessibility-report.json)

</details>
`;

    return comment;
  }
}